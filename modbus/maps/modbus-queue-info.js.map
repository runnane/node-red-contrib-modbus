{"version":3,"sources":["modbus-queue-info.js"],"names":["module","exports","RED","install","mbBasics","require","coreModbusQueue","node","registerType","removeModbusQueueActionsFromNode","config","nodes","createNode","this","name","internalDebugLog","topic","unitid","parseInt","lowLowLevel","ModbusQueueInfo","highLevel","highHighLevel","lowLevel","updateOnAllUnitQueues","queueReadIntervalTime","updateOnAllQueueChanges","Map","queueReadInterval","unitsWithQueue","getNode","server","modbusClient","initUnitQueueStates","unit","registerForModbus","resetStates","unitWithQueue","get","lowLowLevelReached","lowLevelReached","highLevelReached","err","msg","highHighLevelReached","sendEmptyMsgOnFail","checkLowLevelReached","bufferCommandListLength","now","state","modbusClientName","payload","checkHighLevelReached","Date","id","warn","send","Error","getStatusSituationFillColor","fillColor","errorOnHighLevel","setNodeStatusByActivity","showStatusActivities","status","readFromQueue","updateStatusRrunning","bufferCommands","Promise","resolve","reject","bufferCommandList","length","checkQueueStates","readFromAllUnitQueues","eventCallback","on","registerModbusQueueActionsToNode","removeListener","setNodeStatusTo","queueEnabled","msgUnitId","resetQueue","unitId","errorProtocolMsg","queues","queue","queueOptions","allQueueData","verbose","infoText","lowlowLevel","msgQueueReset","shape","settings","fill","text","clearInterval","deregisterForModbus","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-queue-info.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n **/\r\n\r\n/**\r\n * Modbus Read node.\r\n * @module NodeRedModbusRead\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const coreModbusQueue = require('./core/modbus-queue-core')\r\n  const internalDebugLog = require('debug')('contribModbus:queue')\r\n\r\n  function ModbusQueueInfo (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.topic = config.topic\r\n    this.unitid = parseInt(config.unitid) || 1\r\n    this.lowLowLevel = parseInt(config.lowLowLevel)\r\n    this.lowLevel = parseInt(config.lowLevel)\r\n    this.highLevel = parseInt(config.highLevel)\r\n    this.highHighLevel = parseInt(config.highHighLevel)\r\n    this.errorOnHighLevel = config.errorOnHighLevel\r\n    this.queueReadIntervalTime = config.queueReadIntervalTime || 1000\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.updateOnAllQueueChanges = config.updateOnAllQueueChanges\r\n    this.updateOnAllUnitQueues = config.updateOnAllUnitQueues\r\n\r\n    this.internalDebugLog = internalDebugLog\r\n\r\n    const node = this\r\n    node.queueReadInterval = null\r\n    node.updateStatusRrunning = false\r\n    node.unitsWithQueue = new Map()\r\n    mbBasics.setNodeStatusTo('waiting', node)\r\n\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n    modbusClient.registerForModbus(node)\r\n\r\n    node.initUnitQueueStates = function () {\r\n      for (let unit = 0; unit < 256; unit += 1) {\r\n        node.unitsWithQueue.set(unit, {})\r\n        node.resetStates(unit)\r\n      }\r\n    }\r\n\r\n    node.resetStates = function (unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      unitWithQueue.lowLowLevelReached = true\r\n      unitWithQueue.lowLevelReached = false\r\n      unitWithQueue.highLevelReached = false\r\n      unitWithQueue.highHighLevelReached = false\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.initUnitQueueStates()\r\n\r\n    node.checkLowLevelReached = function (node, bufferCommandListLength, unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      if (!unitWithQueue.lowLevelReached && bufferCommandListLength > node.lowLowLevel && bufferCommandListLength < node.lowLevel) {\r\n        unitWithQueue.lowLevelReached = true\r\n        const msg = {\r\n          payload: Date.now(),\r\n          topic: node.topic,\r\n          state: 'low level reached',\r\n          unitid: unit,\r\n          modbusClientName: modbusClient.name,\r\n          bufferCommandListLength: bufferCommandListLength\r\n        }\r\n        node.send(msg)\r\n      }\r\n    }\r\n\r\n    node.checkHighLevelReached = function (node, bufferCommandListLength, unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      if (!unitWithQueue.highLevelReached &&\r\n        bufferCommandListLength > node.lowLevel &&\r\n        bufferCommandListLength > node.highLevel) {\r\n        unitWithQueue.highLevelReached = true\r\n        const msg = {\r\n          payload: Date.now(),\r\n          topic: node.topic,\r\n          state: 'high level reached',\r\n          unitid: unit,\r\n          modbusClientName: modbusClient.name || modbusClient.id,\r\n          highLevel: node.highLevel,\r\n          bufferCommandListLength: bufferCommandListLength\r\n        }\r\n\r\n        if (node.errorOnHighLevel) {\r\n          node.error(new Error('Queue High Level Reached'), msg)\r\n        } else {\r\n          node.warn(msg)\r\n        }\r\n\r\n        node.send(msg)\r\n      }\r\n    }\r\n\r\n    node.checkHighHighLevelReached = function (node, bufferCommandListLength, unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      if (!unitWithQueue.highHighLevelReached &&\r\n        bufferCommandListLength > node.highLevel &&\r\n        bufferCommandListLength > node.highHighLevel) {\r\n        unitWithQueue.highHighLevelReached = true\r\n        const msg = {\r\n          payload: Date.now(),\r\n          topic: node.topic,\r\n          state: 'high high level reached',\r\n          unitid: unit,\r\n          modbusClientName: modbusClient.name || modbusClient.id,\r\n          highLevel: node.highLevel,\r\n          highHighLevel: node.highHighLevel,\r\n          bufferCommandListLength: bufferCommandListLength\r\n        }\r\n        node.error(new Error('Queue High High Level Reached'), msg)\r\n        node.send(msg)\r\n      }\r\n    }\r\n\r\n    node.getStatusSituationFillColor = function (unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      let fillColor = 'blue'\r\n\r\n      if (unitWithQueue.lowLevelReached) {\r\n        fillColor = 'green'\r\n      }\r\n\r\n      if (unitWithQueue.highLevelReached) {\r\n        if (node.errorOnHighLevel) {\r\n          fillColor = 'red'\r\n        } else {\r\n          fillColor = 'yellow'\r\n        }\r\n      }\r\n\r\n      if (unitWithQueue.highHighLevelReached) {\r\n        fillColor = 'red'\r\n      }\r\n\r\n      return fillColor\r\n    }\r\n\r\n    node.setNodeStatusByActivity = function (bufferCommandListLength, unit) {\r\n      if (node.showStatusActivities) {\r\n        node.status({\r\n          fill: node.getStatusSituationFillColor(node.unitid),\r\n          shape: 'ring',\r\n          text: (bufferCommandListLength) ? 'active unit ' + unit + ' queue items: ' + bufferCommandListLength : 'active (Unit-Id: ' + unit + ') empty'\r\n        })\r\n      }\r\n    }\r\n\r\n    node.readFromQueue = function () {\r\n      if (node.updateStatusRrunning) {\r\n        return\r\n      }\r\n      const unit = ((node.unitid < 1 || node.unitid > 255)) ? 1 : node.unitid\r\n      if (modbusClient.bufferCommands) {\r\n        return new Promise(\r\n          function (resolve, reject) {\r\n            try {\r\n              node.updateStatusRrunning = true\r\n              const bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\r\n              node.checkQueueStates(bufferCommandListLength, unit)\r\n              node.setNodeStatusByActivity(bufferCommandListLength, unit)\r\n              node.updateStatusRrunning = false\r\n              resolve()\r\n            } catch (err) {\r\n              node.updateStatusRrunning = false\r\n              reject(err)\r\n            }\r\n          })\r\n      } else {\r\n        if (node.showStatusActivities) {\r\n          node.setNodeStatusByActivity(null, unit)\r\n        }\r\n      }\r\n    }\r\n\r\n    node.checkQueueStates = function (bufferCommandListLength, unit) {\r\n      const unitWithQueue = node.unitsWithQueue.get(unit)\r\n      if (!unitWithQueue.lowLowLevelReached && bufferCommandListLength < node.lowLowLevel) {\r\n        node.resetStates(unit)\r\n      }\r\n      node.checkLowLevelReached(node, bufferCommandListLength, unit)\r\n      node.checkHighLevelReached(node, bufferCommandListLength, unit)\r\n      node.checkHighHighLevelReached(node, bufferCommandListLength, unit)\r\n    }\r\n\r\n    node.readFromAllUnitQueues = function () {\r\n      if (node.updateStatusRrunning) {\r\n        return\r\n      }\r\n\r\n      if (modbusClient.bufferCommands) {\r\n        return new Promise(\r\n          function (resolve, reject) {\r\n            try {\r\n              node.updateStatusRrunning = true\r\n              let bufferCommandListLength = 0\r\n              for (let unit = 0; unit < 256; unit += 1) {\r\n                bufferCommandListLength = modbusClient.bufferCommandList.get(unit).length\r\n                if (!bufferCommandListLength) {\r\n                  continue\r\n                }\r\n                node.checkQueueStates(bufferCommandListLength, unit)\r\n              }\r\n              node.updateStatusRrunning = false\r\n              resolve()\r\n            } catch (err) {\r\n              node.updateStatusRrunning = false\r\n              reject(err)\r\n            }\r\n          })\r\n      }\r\n    }\r\n\r\n    node.registerModbusQueueActionsToNode = function (eventCallback) {\r\n      if (node.updateOnAllQueueChanges) { // much more CPU-Load on many parallel requests to the client\r\n        modbusClient.on('mbqueue', eventCallback) // en-queue\r\n      }\r\n      modbusClient.on('mbactive', eventCallback) // de-queue\r\n      modbusClient.on('mbinit', eventCallback)\r\n      modbusClient.on('mbconnected', eventCallback)\r\n      modbusClient.on('mberror', eventCallback)\r\n      modbusClient.on('mbclosed', eventCallback)\r\n      node.queueReadInterval = setInterval(eventCallback, node.queueReadIntervalTime)\r\n    }\r\n\r\n    node.removeModbusQueueActionsFromNode = function (eventCallback) {\r\n      modbusClient.removeListener('mbqueue', eventCallback)\r\n      modbusClient.removeListener('mbactive', eventCallback)\r\n      modbusClient.removeListener('mbinit', eventCallback)\r\n      modbusClient.removeListener('mbconnected', eventCallback)\r\n      modbusClient.removeListener('mberror', eventCallback)\r\n      modbusClient.removeListener('mbclosed', eventCallback)\r\n    }\r\n\r\n    if (node.updateOnAllUnitQueues) {\r\n      node.registerModbusQueueActionsToNode(node.readFromAllUnitQueues)\r\n      mbBasics.setNodeStatusTo('active for all queues', node)\r\n    } else {\r\n      node.registerModbusQueueActionsToNode(node.readFromQueue)\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      let msgUnitId = node.unitid\r\n      msg.payload = {}\r\n      msg.payload.queueEnabled = modbusClient.bufferCommands\r\n\r\n      if (node.updateOnAllUnitQueues) {\r\n        msg.payload.allQueueData = true\r\n        msg.payload.queues = modbusClient.bufferCommandList\r\n      } else {\r\n        try {\r\n          if (msg.payload.resetQueue) {\r\n            msgUnitId = parseInt(msg.payload.unitId) || node.unitid\r\n          } else {\r\n            msgUnitId = parseInt(msg.payload) || node.unitid\r\n          }\r\n        } catch (err) {\r\n          node.errorProtocolMsg(err, msg)\r\n          msgUnitId = node.unitid\r\n        }\r\n        msg.payload.allQueueData = false\r\n        msg.payload.unitid = msgUnitId\r\n        msg.payload.queue = modbusClient.bufferCommandList.get(msgUnitId)\r\n      }\r\n\r\n      msg.payload.queueOptions = {\r\n        date: Date.now(),\r\n        state: 'queue request',\r\n        modbusClientName: modbusClient.name || modbusClient.id,\r\n        lowlowLevel: node.lowlowLevel,\r\n        unitId: msgUnitId,\r\n        lowLevel: node.lowLevel,\r\n        highLevel: node.highLevel,\r\n        highHighLevel: node.highHighLevel\r\n      }\r\n\r\n      const msgQueueReset = msg.payload.resetQueue || msg.resetQueue\r\n      if (msgQueueReset && modbusClient.bufferCommands) {\r\n        coreModbusQueue.initQueue(modbusClient)\r\n        if (RED.settings.verbose) {\r\n          const infoText = 'Init Queue By External Node'\r\n          modbusClient.warn(infoText)\r\n          internalDebugLog(infoText)\r\n        }\r\n        node.initUnitQueueStates()\r\n\r\n        if (node.showStatusActivities) {\r\n          node.status({\r\n            fill: 'blue',\r\n            shape: 'ring',\r\n            text: 'active empty unit queue'\r\n          })\r\n        }\r\n        msg.payload.queueOptions.state = 'queue reset done'\r\n      }\r\n\r\n      node.send(msg)\r\n    })\r\n\r\n    node.on('close', function (done) {\r\n      if (node.updateOnAllUnitQueues) {\r\n        node.removeModbusQueueActionsFromNode(node.readFromAllUnitQueues)\r\n      } else {\r\n        node.removeModbusQueueActionsFromNode(node.readFromQueue)\r\n      }\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      if (node.queueReadInterval) {\r\n        clearInterval(node.queueReadInterval)\r\n      }\r\n      node.queueReadInterval = null\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    if (!node.showStatusActivities) {\r\n      mbBasics.setNodeDefaultStatus(node)\r\n    }\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-queue-info', ModbusQueueInfo)\r\n}\r\n"]}