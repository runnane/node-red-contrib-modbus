{"version":3,"sources":["modbus-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","mbBasics","setNodeDefaultStatus","config","nodes","createNode","this","name","unitid","internalDebugLog","adr","quantity","ModbusGetter","showStatusActivities","dataType","showErrors","getNode","ioFile","msgThruput","connection","logIOActivities","useIOForPayload","emptyMsgOnFail","node","verboseLogging","settings","setNodeStatusTo","server","modbusClient","registerForModbus","initModbusClientEvents","resp","msg","data","buildMessageWithIO","logMsgError","err","sendEmptyMsgOnFail","origMsg","getOriginalMessage","bufferMessageList","errorProtocolMsg","onModbusCommandError","emit","getObjectId","topic","id","messageId","payload","value","on","invalidPayloadIn","client","assign","newMsg","buildNewMessageObject","origMsgInput","set","buildNewMessage","keepMsgProperties","Object","onModbusCommandDone","done","clear","deregisterForModbus"],"mappings":"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","file":"../modbus-getter.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n */\r\n/**\r\n * Modbus Getter node.\r\n * @module NodeRedModbusGetter\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const mbCore = require('./core/modbus-core')\r\n  const mbIOCore = require('./core/modbus-io-core')\r\n  const internalDebugLog = require('debug')('contribModbus:getter')\r\n\r\n  function ModbusGetter (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.unitid = config.unitid\r\n\r\n    this.dataType = config.dataType\r\n    this.adr = config.adr\r\n    this.quantity = config.quantity\r\n\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n    this.msgThruput = config.msgThruput\r\n    this.connection = null\r\n\r\n    this.useIOFile = config.useIOFile\r\n    this.ioFile = RED.nodes.getNode(config.ioFile)\r\n    this.useIOForPayload = config.useIOForPayload\r\n    this.logIOActivities = config.logIOActivities\r\n\r\n    this.emptyMsgOnFail = config.emptyMsgOnFail\r\n    this.keepMsgProperties = config.keepMsgProperties\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n    node.bufferMessageList = new Map()\r\n    mbBasics.setNodeStatusTo('waiting', node)\r\n\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n    modbusClient.registerForModbus(node)\r\n    mbBasics.initModbusClientEvents(node, modbusClient)\r\n\r\n    node.onModbusCommandDone = function (resp, msg) {\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo('reading done', node)\r\n      }\r\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\r\n      node.emit('modbusGetterNodeDone')\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.onModbusCommandError = function (err, msg) {\r\n      node.internalDebugLog(err.message)\r\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\r\n      node.errorProtocolMsg(err, origMsg)\r\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\r\n      node.emit('modbusGetterNodeError')\r\n    }\r\n\r\n    node.buildNewMessageObject = function (node, msg) {\r\n      const messageId = mbCore.getObjectId()\r\n      return {\r\n        topic: msg.topic || node.id,\r\n        messageId,\r\n        payload: {\r\n          value: msg.payload.value || msg.payload,\r\n          unitid: node.unitid,\r\n          fc: mbCore.functionCodeModbusRead(node.dataType),\r\n          address: node.adr,\r\n          quantity: node.quantity,\r\n          messageId\r\n        }\r\n      }\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      if (mbBasics.invalidPayloadIn(msg)) {\r\n        return\r\n      }\r\n\r\n      if (!modbusClient.client) {\r\n        return\r\n      }\r\n\r\n      const origMsgInput = Object.assign({}, msg) // keep it origin\r\n      try {\r\n        const newMsg = node.buildNewMessageObject(node, origMsgInput)\r\n        node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, origMsgInput, newMsg))\r\n        modbusClient.emit('readModbus', newMsg, node.onModbusCommandDone, node.onModbusCommandError)\r\n\r\n        if (node.showStatusActivities) {\r\n          mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\r\n        }\r\n      } catch (err) {\r\n        node.errorProtocolMsg(err, origMsgInput)\r\n      }\r\n    })\r\n\r\n    node.on('close', function (done) {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      node.bufferMessageList.clear()\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    if (!node.showStatusActivities) {\r\n      mbBasics.setNodeDefaultStatus(node)\r\n    }\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-getter', ModbusGetter)\r\n}\r\n"]}