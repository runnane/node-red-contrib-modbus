{"version":3,"sources":["modbus-response-filter.js"],"names":["module","exports","RED","require","install","mbBasics","modbusIOFileValuNames","httpAdmin","config","mbCore","createNode","this","filter","registers","filterResponseBuffer","nodes","name","filterInput","showErrors","ioFile","node","configData","setNodeStatusTo","msg","filterFromPayload","payload","item","responseBuffer","values","input","on","invalidPayloadIn","length","send","error","Error","internalDebug","get","auth","needsPermission","req","res","json"],"mappings":"aAUAA,OAAAC,QAAA,SAAAC,GAEAC,QAAA,sBAAAC,UACAJ,IAAOC,EAAUE,QAAA,sBACfE,EAAAF,QAAA,mBAIIG,EAAwB,GA2E5BJ,EAAIK,MAAAA,aAAc,yBAzElB,SAA+BC,GAJ/BN,EAAMO,MAAMC,WAAWC,KAAAH,GACvBG,KAAMN,KAAQG,EAAGL,KAOfQ,KAAKC,OAASJ,EAAOI,OANvBD,KAAIL,UAAAA,SAAwBE,EAA5BK,YAAA,KAEAF,KAAAG,qBAA+BN,EAA/BM,qBACEZ,KAAIa,aAAJP,EAA2BA,aAE3BG,KAAKK,YAAcA,EAAnBC,YAEAN,KAAKE,qBAAqBL,EAAOK,qBAEjCF,KAAKG,WAAAA,EAALI,WAEAP,KAAKM,OAAAA,EAALF,MAAmBP,QAAOS,EAA1BE,QAGA,IAAKD,EAAAA,KAILZ,EAAAc,EAAAD,OAAAE,WAIAhB,EAASiB,gBAAgB,SAAUF,GAGjCd,EAAAA,OAAAA,GAAAA,gBAAwBe,SAAxBA,GADFf,EAAAe,IAKEE,EAAGC,kBAAeC,SAAeF,GADnC,OAEIA,EAAAE,QAAYT,EAALS,QAAcL,OAAKR,SAA1Bc,GADF,OAAAA,EAAAV,OAAAI,EAAAR,SAKEQ,EAAOG,6BACRA,EAAAI,eAGCP,EAAOG,qBACRA,EAAAK,OAGCR,EAAOG,oBACRA,EAAAM,MAfHN,GAqBEH,EAAAU,GAAIzB,QAAS0B,SAAAA,GACX1B,EAAA0B,iBAAAR,OAIAH,EAAKG,WAA0BE,EAAdO,EAAbnB,YACFU,EAAIH,QAAKF,QAAYK,EAAAE,QAAAO,SAAAZ,EAAAP,UASvBO,EAAKa,KAAKb,EAAKI,kBAAkBD,KAR7BH,EAAKc,YACNd,EAAAc,MAAA,IAAAC,MAAAZ,EAAAE,QAAAO,OAAA,mBAAAZ,EAAAP,YACDJ,EAAO2B,cAAcb,EAAIE,QAAQO,OAAS,mCAAqCZ,EAAKP,UAAY,uBAWpGR,EAAAA,GAAAA,QAASiB,WADXjB,EAAAiB,gBAAA,SAAAF,OASDlB,EAFDK,UAAA8B,IAAA,4BAAAnC,EAAAoC,KAAAC,gBAAA,eAAA,SAAAC,EAAAC,GAhFFA,EAAAC,KAAApC","file":"../modbus-response-filter.js","sourcesContent":["/**\r\n Copyright (c) 2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n */\r\n/**\r\n * Modbus flexible Getter node.\r\n * @module NodeRedModbusFlexGetter\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbCore = require('./core/modbus-core')\r\n  const mbBasics = require('./modbus-basics')\r\n  let modbusIOFileValuNames = []\r\n\r\n  function ModbusResponseFilter (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.filter = config.filter\r\n    this.registers = parseInt(config.registers) || null\r\n\r\n    this.filterResponseBuffer = config.filterResponseBuffer\r\n    this.filterValues = config.filterValues\r\n    this.filterInput = config.filterInput\r\n\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n\r\n    this.ioFile = RED.nodes.getNode(config.ioFile)\r\n\r\n    const node = this\r\n\r\n    modbusIOFileValuNames = node.ioFile.configData\r\n\r\n    mbBasics.setNodeStatusTo('active', node)\r\n\r\n    node.ioFile.on('updatedConfig', function (configData) {\r\n      modbusIOFileValuNames = configData\r\n    })\r\n\r\n    node.filterFromPayload = function (msg) {\r\n      msg.payload = msg.payload.filter((item) => {\r\n        return item.name === node.filter\r\n      })\r\n\r\n      if (node.filterResponseBuffer) {\r\n        delete msg.responseBuffer\r\n      }\r\n\r\n      if (node.filterValues) {\r\n        delete msg.values\r\n      }\r\n\r\n      if (node.filterInput) {\r\n        delete msg.input\r\n      }\r\n\r\n      return msg\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      if (mbBasics.invalidPayloadIn(msg)) {\r\n        return\r\n      }\r\n\r\n      if (node.registers && node.registers > 0) {\r\n        if (!msg.payload.length || msg.payload.length !== node.registers) {\r\n          if (node.showErrors) {\r\n            node.error(new Error(msg.payload.length + ' does not match ' + node.registers))\r\n          }\r\n          mbCore.internalDebug(msg.payload.length + ' Registers And Filter Length Of ' + node.registers + ' Does Not Match')\r\n        } else {\r\n          node.send(node.filterFromPayload(msg))\r\n        }\r\n      } else {\r\n        // without register safety\r\n        node.send(node.filterFromPayload(msg))\r\n      }\r\n    })\r\n\r\n    node.on('close', function () {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n    })\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-response-filter', ModbusResponseFilter)\r\n\r\n  RED.httpAdmin.get('/modbus/iofile/valuenames', RED.auth.needsPermission('iofile.read'), function (req, res) {\r\n    res.json(modbusIOFileValuNames)\r\n  })\r\n}\r\n"]}