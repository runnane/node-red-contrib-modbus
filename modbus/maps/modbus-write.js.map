{"version":3,"sources":["modbus-write.js"],"names":["module","exports","RED","require","install","mbCore","internalDebugLog","nodes","registerType","config","mbBasics","createNode","this","name","showStatusActivities","unitid","ModbusWrite","dataType","Number","adr","emptyMsgOnFail","keepMsgProperties","quantity","verbose","node","setNodeStatusTo","getNode","server","modbusClient","registerForModbus","initModbusClientEvents","resp","msg","bufferMessageList","payload","emit","err","logMsgError","sendEmptyMsgOnFail","message","origMsg","getOriginalMessage","onModbusWriteError","Object","prototype","hasOwnProperty","call","setMsgPayloadFromHTTPRequests","value","JSON","parse","buildNewMessageObject","messageId","getObjectId","topic","id","functionCodeModbusWrite","fc","on","origMsgInput","assign","invalidPayloadIn","client","httpMsg","newMsg","set","buildNewMessage","actualServiceState","onModbusWriteDone","done","clear","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-write.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\r\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\r\n All rights reserved.\r\n node-red-contrib-modbus\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n **/\r\n/**\r\n * Modbus Write node.\r\n * @module NodeRedModbusWrite\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const mbCore = require('./core/modbus-core')\r\n  const internalDebugLog = require('debug')('contribModbus:write')\r\n\r\n  function ModbusWrite (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n\r\n    this.unitid = config.unitid\r\n    this.dataType = config.dataType\r\n    this.adr = Number(config.adr)\r\n    this.quantity = config.quantity\r\n\r\n    this.emptyMsgOnFail = config.emptyMsgOnFail\r\n    this.keepMsgProperties = config.keepMsgProperties\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n    node.bufferMessageList = new Map()\r\n\r\n    mbBasics.setNodeStatusTo('waiting', node)\r\n\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n    modbusClient.registerForModbus(node)\r\n    mbBasics.initModbusClientEvents(node, modbusClient)\r\n\r\n    node.onModbusWriteDone = function (resp, msg) {\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo('write done', node)\r\n      }\r\n\r\n      node.send(mbCore.buildMessage(node.bufferMessageList, msg.payload, resp, msg))\r\n      node.emit('modbusWriteNodeDone')\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.onModbusWriteError = function (err, msg) {\r\n      node.internalDebugLog(err.message)\r\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\r\n      node.errorProtocolMsg(err, origMsg)\r\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\r\n      node.emit('modbusWriteNodeError')\r\n    }\r\n\r\n    node.setMsgPayloadFromHTTPRequests = function (msg) {\r\n      /* HTTP requests for boolean and multiple data string [1,2,3,4,5] */\r\n      if (Object.prototype.hasOwnProperty.call(msg.payload, 'value') &&\r\n        typeof msg.payload.value === 'string') {\r\n        if (msg.payload.value === 'true' || msg.payload.value === 'false') {\r\n          msg.payload.value = (msg.payload.value === 'true')\r\n        } else {\r\n          if (msg.payload.value.indexOf(',') > -1) {\r\n            msg.payload.value = JSON.parse(msg.payload.value)\r\n          }\r\n        }\r\n      }\r\n      return msg\r\n    }\r\n\r\n    node.buildNewMessageObject = function (node, msg) {\r\n      const messageId = mbCore.getObjectId()\r\n      return {\r\n        topic: msg.topic || node.id,\r\n        messageId,\r\n        payload: {\r\n          value: (Object.prototype.hasOwnProperty.call(msg.payload, 'value')) ? msg.payload.value : msg.payload,\r\n          unitid: node.unitid,\r\n          fc: mbCore.functionCodeModbusWrite(node.dataType),\r\n          address: node.adr,\r\n          quantity: node.quantity,\r\n          messageId\r\n        }\r\n      }\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      const origMsgInput = Object.assign({}, msg)\r\n\r\n      if (mbBasics.invalidPayloadIn(msg)) {\r\n        return\r\n      }\r\n\r\n      if (!modbusClient.client) {\r\n        return\r\n      }\r\n\r\n      try {\r\n        const httpMsg = node.setMsgPayloadFromHTTPRequests(origMsgInput)\r\n        const newMsg = node.buildNewMessageObject(node, httpMsg)\r\n        node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, httpMsg, newMsg))\r\n        modbusClient.emit('writeModbus', newMsg, node.onModbusWriteDone, node.onModbusWriteError)\r\n\r\n        if (node.showStatusActivities) {\r\n          mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\r\n        }\r\n      } catch (err) {\r\n        node.errorProtocolMsg(err, origMsgInput)\r\n      }\r\n    })\r\n\r\n    node.on('close', function (done) {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      node.bufferMessageList.clear()\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    if (!node.showStatusActivities) {\r\n      mbBasics.setNodeDefaultStatus(node)\r\n    }\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-write', ModbusWrite)\r\n}\r\n"]}