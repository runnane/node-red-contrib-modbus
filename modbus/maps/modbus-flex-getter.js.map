{"version":3,"sources":["modbus-flex-getter.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","nodes","registerType","config","createNode","this","name","showStatusActivities","showErrors","internalDebugLog","useIOFile","ModbusFlexGetter","getNode","ioFile","useIOForPayload","connection","emptyMsgOnFail","node","keepMsgProperties","mbBasics","server","bufferMessageList","modbusClient","registerForModbus","onModbusReadDone","resp","msg","buildMessageWithIO","data","errorProtocolMsg","err","logMsgError","sendEmptyMsgOnFail","message","origMsg","setModbusError","onModbusReadError","emit","JSON","parse","payload","prepareMsg","parseInt","fc","unitid","address","quantity","isValidModbusMsg","isValid","Number","isInteger","error","messageId","getObjectId","value","on","origMsgInput","assign","client","Object","newMsg","buildNewMessageObject","set","buildNewMessage","inputMsg","setNodeStatusTo","actualServiceState","deregisterForModbus","clear","id","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-getter.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n */\r\n/**\r\n * Modbus flexible Getter node.\r\n * @module NodeRedModbusFlexGetter\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const mbCore = require('./core/modbus-core')\r\n  const mbIOCore = require('./core/modbus-io-core')\r\n  const internalDebugLog = require('debug')('contribModbus:flex:getter')\r\n\r\n  function ModbusFlexGetter (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n    this.connection = null\r\n\r\n    this.useIOFile = config.useIOFile\r\n    this.ioFile = RED.nodes.getNode(config.ioFile)\r\n    this.useIOForPayload = config.useIOForPayload\r\n    this.logIOActivities = config.logIOActivities\r\n\r\n    this.emptyMsgOnFail = config.emptyMsgOnFail\r\n    this.keepMsgProperties = config.keepMsgProperties\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n    node.bufferMessageList = new Map()\r\n    mbBasics.setNodeStatusTo('waiting', node)\r\n\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n    modbusClient.registerForModbus(node)\r\n    mbBasics.initModbusClientEvents(node, modbusClient)\r\n\r\n    node.onModbusReadDone = function (resp, msg) {\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo('reading done', node)\r\n      }\r\n\r\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\r\n      node.emit('modbusFlexGetterNodeDone')\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.onModbusReadError = function (err, msg) {\r\n      node.internalDebugLog(err.message)\r\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\r\n      node.errorProtocolMsg(err, origMsg)\r\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\r\n      node.emit('modbusFlexGetterNodeError')\r\n    }\r\n\r\n    node.prepareMsg = function (msg) {\r\n      if (typeof msg.payload === 'string') {\r\n        msg.payload = JSON.parse(msg.payload)\r\n      }\r\n\r\n      msg.payload.fc = parseInt(msg.payload.fc) || 3\r\n      msg.payload.unitid = parseInt(msg.payload.unitid)\r\n      msg.payload.address = parseInt(msg.payload.address) || 0\r\n      msg.payload.quantity = parseInt(msg.payload.quantity) || 1\r\n\r\n      return msg\r\n    }\r\n\r\n    node.isValidModbusMsg = function (msg) {\r\n      let isValid = true\r\n\r\n      if (!(Number.isInteger(msg.payload.fc) &&\r\n              msg.payload.fc >= 1 &&\r\n              msg.payload.fc <= 4)) {\r\n        node.error('FC Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      if (isValid &&\r\n            !(Number.isInteger(msg.payload.address) &&\r\n            msg.payload.address >= 0 &&\r\n            msg.payload.address <= 65535)) {\r\n        node.error('Address Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      if (isValid &&\r\n            !(Number.isInteger(msg.payload.quantity) &&\r\n            msg.payload.quantity >= 1 &&\r\n            msg.payload.quantity <= 65535)) {\r\n        node.error('Quantity Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      return isValid\r\n    }\r\n\r\n    node.buildNewMessageObject = function (node, msg) {\r\n      const messageId = mbCore.getObjectId()\r\n      return {\r\n        topic: msg.topic || node.id,\r\n        messageId,\r\n        payload: {\r\n          value: msg.payload.value || msg.value,\r\n          unitid: msg.payload.unitid,\r\n          fc: msg.payload.fc,\r\n          address: msg.payload.address,\r\n          quantity: msg.payload.quantity,\r\n          emptyMsgOnFail: node.emptyMsgOnFail,\r\n          keepMsgProperties: node.keepMsgProperties,\r\n          messageId\r\n        }\r\n      }\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      if (mbBasics.invalidPayloadIn(msg) || !modbusClient.client) {\r\n        return\r\n      }\r\n\r\n      const origMsgInput = Object.assign({}, msg) // keep it origin\r\n      try {\r\n        const inputMsg = node.prepareMsg(origMsgInput)\r\n        if (node.isValidModbusMsg(inputMsg)) {\r\n          const newMsg = node.buildNewMessageObject(node, inputMsg)\r\n          node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\r\n          modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\r\n        }\r\n      } catch (err) {\r\n        node.errorProtocolMsg(err, origMsgInput)\r\n      }\r\n\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\r\n      }\r\n    })\r\n\r\n    node.on('close', function (done) {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      node.bufferMessageList.clear()\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    if (!node.showStatusActivities) {\r\n      mbBasics.setNodeDefaultStatus(node)\r\n    }\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-flex-getter', ModbusFlexGetter)\r\n}\r\n"]}