{"version":3,"sources":["core/modbus-io-core.js"],"names":["require","install","de","biancoroyal","modbus","io","core","internalDebug","LineByLineReader","nameValuesFromIOFile","node","msg","values","response","readingOffset","valueNames","ioCore","ioFile","configData","forEach","mapping","push","buildInputAddressMapping","Number","addressOffset","logIOActivities","buildOutputAddressMapping","valueAddress","startsWith","allValueNamesFromIOFile","ioNode","insertValues","getDataTypeFromFirstCharType","type","registerName","offset","logging","addressStart","coilStart","bits","bitAddress","name","substring","registerType","addressType","split","Math","floor","addressStartIO","addressOffsetIO","Bit","dataType","error","register","registerAddress","index","item","prototype","hasOwnProperty","call","JSON","stringify","value","pow","getValueFromBufferByDataType","bufferOffset","responseBuffer","registerLength","length","readUInt16BE","isRegisterSizeWrong","readInt8","readInt16BE","convertedValue","readIntBE","readFloatBE","readDoubleBE","readUInt32BE","readUIntBE","convertValuesByType","Object","readInt32BE","buffer","err","message","filterValueNames","fc","adr","quantity","functionType","startRegister","endRegister","filter","valueName","start","sizeDivisor","sixteenBitBufferLength","buildMessageWithIO","bufferMessageList","origMsg","modbusRequest","assign","payload","topic","rawMsg","lastUpdatedAt","parseInt","this","allValueNames","address","module","exports"],"mappings":"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","file":"../../core/modbus-io-core.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus\r\n node-red-contrib-modbusio\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n */\r\n'use strict'\r\nrequire('source-map-support').install()\r\n\r\n// eslint-disable-next-line no-var\r\nvar de = de || { biancoroyal: { modbus: { io: { core: {} } } } } // eslint-disable-line no-use-before-define\r\nde.biancoroyal.modbus.io.core.internalDebug = de.biancoroyal.modbus.io.core.internalDebug || require('debug')('contribModbus:io:core') // eslint-disable-line no-use-before-define\r\nde.biancoroyal.modbus.io.core.LineByLineReader = de.biancoroyal.modbus.io.core.LineByLineReader || require('line-by-line') // eslint-disable-line no-use-before-define\r\nde.biancoroyal.modbus.io.core.core = de.biancoroyal.modbus.io.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\r\n\r\nde.biancoroyal.modbus.io.core.nameValuesFromIOFile = function (node, msg, values, response, readingOffset) {\r\n  let valueNames = []\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n\r\n  if (node.ioFile && node.ioFile.configData) {\r\n    node.ioFile.configData.forEach(function (mapping) {\r\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\r\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\r\n      }\r\n\r\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\r\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(node.ioFile.addressOffset), Number(readingOffset), node.logIOActivities))\r\n      }\r\n    })\r\n  }\r\n\r\n  valueNames = ioCore.insertValues(valueNames, values, node.logIOActivities)\r\n\r\n  return ioCore.convertValuesByType(valueNames, values, response, node.logIOActivities)\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.allValueNamesFromIOFile = function (ioNode) {\r\n  const valueNames = []\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n\r\n  if (ioNode && ioNode.configData) {\r\n    ioNode.configData.forEach(function (mapping) {\r\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%I')) {\r\n        valueNames.push(ioCore.buildInputAddressMapping('MB-INPUTS', mapping, Number(ioNode.addressOffset), 0))\r\n      }\r\n\r\n      if (mapping.valueAddress && mapping.valueAddress.startsWith('%Q')) {\r\n        valueNames.push(ioCore.buildOutputAddressMapping('MB-OUTPUTS', mapping, Number(ioNode.addressOffset), 0))\r\n      }\r\n    })\r\n  }\r\n\r\n  return valueNames\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.getDataTypeFromFirstCharType = function (type) {\r\n  switch (type) {\r\n    case 'w':\r\n      return 'Word'\r\n    case 'd':\r\n      return 'Double'\r\n    case 'r':\r\n      return 'Real'\r\n    case 'f':\r\n      return 'Float'\r\n    case 'i':\r\n      return 'Integer'\r\n    case 'l':\r\n      return 'Long'\r\n    case 'b':\r\n      return 'Boolean'\r\n    default:\r\n      return 'Unsigned Integer'\r\n  }\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.buildInputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n  let addressStart = 0\r\n  let coilStart = 0\r\n  let addressOffset = 0\r\n  let bits = 0\r\n  let bitAddress = null\r\n\r\n  const type = mapping.name.substring(0, 1)\r\n  const registerType = mapping.valueAddress.substring(2, 3)\r\n  const addressType = mapping.valueAddress.substring(0, 3)\r\n\r\n  switch (type) {\r\n    case 'w': // word\r\n    case 'u': // unsigned integer\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 1\r\n      bits = 16\r\n      break\r\n    case 'i': // integer\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n\r\n      if (registerType === 'W') {\r\n        addressOffset = 1\r\n        bits = 16\r\n      } else {\r\n        addressOffset = 2\r\n        bits = 32\r\n      }\r\n      break\r\n    case 'r': // real\r\n    case 'f': // float\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 2\r\n      bits = 32\r\n      break\r\n    case 'd': // double\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 4\r\n      bits = 64\r\n      break\r\n    case 'l': // long\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 5\r\n      bits = 80\r\n      break\r\n    case 'b': // bit - boolean\r\n      if (registerType === 'X') {\r\n        bitAddress = mapping.valueAddress.split('%IX')[1].split('.')\r\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\r\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\r\n        addressOffset = 1\r\n        bits = 1\r\n      }\r\n      break\r\n    default:\r\n      if (logging) {\r\n        ioCore.internalDebug('unknown input type ' + type)\r\n      }\r\n      bits = 0\r\n  }\r\n\r\n  if (bits) {\r\n    const addressStartIO = addressStart - (Number(offset) || 0)\r\n\r\n    return {\r\n      register: registerName,\r\n      name: mapping.name,\r\n      addressStart: addressStart,\r\n      addressOffset: addressOffset,\r\n      addressOffsetIO: Number(offset) || 0,\r\n      addressStartIO: addressStartIO,\r\n      registerAddress: addressStartIO - Number(readingOffset),\r\n      coilStart: coilStart,\r\n      bitAddress: bitAddress,\r\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\r\n      bits: bits,\r\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\r\n      type: 'input'\r\n    }\r\n  }\r\n\r\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match input mapping' }\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.buildOutputAddressMapping = function (registerName, mapping, offset, readingOffset, logging) {\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n  let addressStart = 0\r\n  let coilStart = 0\r\n  let addressOffset = 0\r\n  let bits = 0\r\n  let bitAddress = null\r\n\r\n  const type = mapping.name.substring(0, 1)\r\n  const registerType = mapping.valueAddress.substring(2, 3)\r\n  const addressType = mapping.valueAddress.substring(0, 3)\r\n\r\n  switch (type) {\r\n    case 'w': // word\r\n    case 'u': // unsigned integer\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 1\r\n      bits = 16\r\n      break\r\n    case 'i': // integer\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n\r\n      if (registerType === 'W') {\r\n        addressOffset = 1\r\n        bits = 16\r\n      } else {\r\n        addressOffset = 2\r\n        bits = 32\r\n      }\r\n      break\r\n    case 'r': // real\r\n    case 'f': // float\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 2\r\n      bits = 32\r\n      break\r\n    case 'd': // double\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 4\r\n      bits = 64\r\n      break\r\n    case 'l': // long\r\n      addressStart = Number(mapping.valueAddress.split(addressType)[1])\r\n      addressOffset = 5\r\n      bits = 80\r\n      break\r\n    case 'b': // bit - boolean\r\n      if (registerType === 'X') {\r\n        bitAddress = mapping.valueAddress.split('%QX')[1].split('.')\r\n        addressStart = Math.floor(Number(bitAddress[0]) / 2)\r\n        coilStart = Number(bitAddress[0]) * 8 + Number(bitAddress[1])\r\n        addressOffset = 1\r\n        bits = 1\r\n      }\r\n      break\r\n    default:\r\n      if (logging) {\r\n        ioCore.internalDebug('unknown output type ' + type)\r\n      }\r\n      bits = 0\r\n  }\r\n\r\n  if (bits) {\r\n    const addressStartIO = addressStart - (Number(offset) || 0)\r\n\r\n    return {\r\n      register: registerName,\r\n      name: mapping.name,\r\n      addressStart: addressStart,\r\n      addressOffset: addressOffset,\r\n      addressOffsetIO: Number(offset) || 0,\r\n      addressStartIO: addressStartIO,\r\n      registerAddress: addressStartIO - Number(readingOffset),\r\n      coilStart: coilStart,\r\n      bitAddress: bitAddress,\r\n      Bit: (bitAddress) ? (Number(bitAddress[0]) * 8) + Number(bitAddress[1]) : 0,\r\n      bits: bits,\r\n      dataType: ioCore.getDataTypeFromFirstCharType(type),\r\n      type: 'output'\r\n    }\r\n  }\r\n\r\n  return { name: mapping.name, type: type, mapping: mapping, error: 'variable name does not match output mapping' }\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.insertValues = function (valueNames, register, logging) {\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n\r\n  let index = 0\r\n  for (index in valueNames) {\r\n    const item = valueNames[index]\r\n\r\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\r\n      if (logging) {\r\n        ioCore.internalDebug('Item Not Valid To Insert Value ' + JSON.stringify(item))\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\r\n      if (logging) {\r\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\r\n      }\r\n      break\r\n    }\r\n\r\n    switch (Number(item.bits)) {\r\n      case 1:\r\n        item.value = !!((register[item.registerAddress] & Math.pow(item.bitAddress[1], 2)))\r\n        break\r\n      case 16:\r\n        item.value = register[item.registerAddress]\r\n        break\r\n      case 32:\r\n        item.value = register[item.registerAddress + 1] << 16 |\r\n          register[item.registerAddress]\r\n        break\r\n      case 64:\r\n        item.value = register[item.registerAddress + 3] << 48 |\r\n          register[item.registerAddress + 2] << 32 |\r\n          register[item.registerAddress + 1] << 16 |\r\n          register[item.registerAddress]\r\n        break\r\n      case 80:\r\n        item.value = register[item.registerAddress + 4] << 64 |\r\n          register[item.registerAddress + 3] << 48 |\r\n          register[item.registerAddress + 2] << 32 |\r\n          register[item.registerAddress + 1] << 16 |\r\n          register[item.registerAddress]\r\n        break\r\n      default:\r\n        item.value = null\r\n        break\r\n    }\r\n  }\r\n\r\n  return valueNames\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.getValueFromBufferByDataType = function (item, bufferOffset, responseBuffer, logging) {\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n  const registerLength = responseBuffer.length / 2\r\n\r\n  if (bufferOffset < 0 || bufferOffset > responseBuffer.length) {\r\n    if (logging) {\r\n      ioCore.internalDebug('Wrong Buffer Access Parameter Type:' + item.dataType + ' Register-Length: ' + registerLength +\r\n        ' Buffer-Length:' + responseBuffer.length + ' Address-Buffer-Offset:' + bufferOffset)\r\n      ioCore.internalDebug(JSON.stringify(item))\r\n    }\r\n    return item\r\n  }\r\n\r\n  if (logging) {\r\n    ioCore.internalDebug('Get Value From Buffer By Data Type:' + item.dataType + ' Register:' + item.registerAddress + ' Bits:' + Number(item.bits))\r\n  }\r\n\r\n  switch (item.dataType) {\r\n    case 'Boolean':\r\n      item.value = !!(responseBuffer.readUInt16BE(bufferOffset) & Math.pow(item.bitAddress[1], 2))\r\n      break\r\n    case 'Word':\r\n      switch (item.bits) {\r\n        case '8':\r\n          item.value = responseBuffer.readInt8(bufferOffset)\r\n          break\r\n        default:\r\n          item.value = responseBuffer.readInt16BE(bufferOffset) // DWord\r\n          item.convertedValue = false\r\n      }\r\n      break\r\n    case 'Integer':\r\n      switch (item.bits) {\r\n        case '8':\r\n          item.value = responseBuffer.readInt8(bufferOffset)\r\n          break\r\n        case '32':\r\n          item.value = responseBuffer.readInt32BE(bufferOffset)\r\n          break\r\n        case '64':\r\n          item.value = responseBuffer.readIntBE(bufferOffset, 8)\r\n          break\r\n        default:\r\n          item.value = responseBuffer.readInt16BE(bufferOffset)\r\n      }\r\n      break\r\n    case 'Real':\r\n    case 'Float':\r\n      item.value = responseBuffer.readFloatBE(bufferOffset, 4)\r\n      break\r\n    case 'Double':\r\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 8)\r\n      break\r\n    case 'Long':\r\n      item.value = responseBuffer.readDoubleBE(bufferOffset, 10)\r\n      break\r\n    default:\r\n      switch (item.bits) {\r\n        case '8':\r\n          item.value = responseBuffer.readUInt8(bufferOffset)\r\n          break\r\n        case '32':\r\n          item.value = responseBuffer.readUInt32BE(bufferOffset)\r\n          break\r\n        case '64':\r\n          item.value = responseBuffer.readUIntBE(bufferOffset, 8)\r\n          break\r\n        default:\r\n          item.value = responseBuffer.readUInt16BE(bufferOffset)\r\n          item.convertedValue = false\r\n      }\r\n      break\r\n  }\r\n\r\n  return item\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.convertValuesByType = function (valueNames, register, responseBuffer, logging) {\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n  let bufferOffset = 0\r\n  const sixteenBitBufferLength = 2\r\n\r\n  let index = 0\r\n  for (index in valueNames) {\r\n    let item = valueNames[index]\r\n\r\n    if (!item || !Object.prototype.hasOwnProperty.call(item, 'dataType') || !Object.prototype.hasOwnProperty.call(item, 'registerAddress') || item.registerAddress < 0) {\r\n      if (logging) {\r\n        ioCore.internalDebug('Item Not Valid To Convert ' + JSON.stringify(item))\r\n      }\r\n      continue\r\n    }\r\n\r\n    if (de.biancoroyal.modbus.io.core.isRegisterSizeWrong(register, item.registerAddress, Number(item.bits))) {\r\n      if (logging) {\r\n        ioCore.internalDebug('Insert Value Register Reached At Address-Start-IO:' + item.registerAddress + ' Bits:' + Number(item.bits))\r\n      }\r\n      break\r\n    }\r\n\r\n    if (responseBuffer.buffer instanceof Buffer) {\r\n      bufferOffset = Number(item.registerAddress) * sixteenBitBufferLength\r\n      try {\r\n        item = ioCore.getValueFromBufferByDataType(item, bufferOffset, responseBuffer.buffer, logging)\r\n      } catch (err) {\r\n        ioCore.internalDebug(err.message)\r\n      }\r\n    } else {\r\n      if (logging) {\r\n        ioCore.internalDebug('Response Buffer Is Not A Buffer')\r\n      }\r\n      break\r\n    }\r\n  }\r\n\r\n  return valueNames\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.filterValueNames = function (node, valueNames, fc, adr, quantity) {\r\n  if (!valueNames.length || !valueNames.filter) {\r\n    return valueNames\r\n  }\r\n\r\n  const ioCore = de.biancoroyal.modbus.io.core\r\n  let functionType = 'input'\r\n\r\n  if (fc === 2 || fc === 4) {\r\n    functionType = 'output'\r\n  }\r\n\r\n  const startRegister = adr\r\n  const endRegister = Number(adr) + Number(quantity) - 1\r\n\r\n  if (node.logIOActivities) {\r\n    ioCore.internalDebug('adr:' + adr + ' quantity:' + quantity + ' startRegister:' + startRegister + ' endRegister:' + endRegister + ' functionType:' + functionType)\r\n  }\r\n\r\n  return valueNames.filter((valueName) => {\r\n    return (valueName.registerAddress >= 0 &&\r\n      valueName.addressStartIO >= startRegister &&\r\n      valueName.addressStartIO <= endRegister &&\r\n      valueName.type === functionType)\r\n  })\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.isRegisterSizeWrong = function (register, start, bits) {\r\n  const sizeDivisor = Number(bits) || 16\r\n  const startRegister = Number(start)\r\n  let endRegister = startRegister\r\n\r\n  if (sizeDivisor > 16) {\r\n    endRegister = startRegister + (sizeDivisor / 16) - 1\r\n  }\r\n\r\n  return (startRegister < 0 || register.length < startRegister || endRegister > register.length)\r\n}\r\n\r\nde.biancoroyal.modbus.io.core.buildMessageWithIO = function (node, values, response, msg) {\r\n  const origMsg = this.core.getOriginalMessage(node.bufferMessageList, msg)\r\n  origMsg.modbusRequest = Object.assign({}, msg.payload)\r\n  origMsg.payload = values\r\n  origMsg.topic = msg.topic\r\n  origMsg.responseBuffer = response\r\n\r\n  const rawMsg = Object.assign({}, origMsg)\r\n  rawMsg.payload = response\r\n  rawMsg.values = values\r\n  delete rawMsg.responseBuffer\r\n\r\n  if (node.useIOFile && node.ioFile.lastUpdatedAt) {\r\n    const allValueNames = this.nameValuesFromIOFile(node, msg, values, response, parseInt(msg.payload.address) || 0)\r\n    const valueNames = this.filterValueNames(node, allValueNames, parseInt(msg.payload.fc) || 3,\r\n      parseInt(msg.payload.address) || 0,\r\n      parseInt(msg.payload.quantity) || 1,\r\n      node.logIOActivities)\r\n\r\n    if (node.useIOForPayload) {\r\n      origMsg.payload = valueNames\r\n      origMsg.values = values\r\n    } else {\r\n      origMsg.payload = values\r\n      origMsg.valueNames = valueNames\r\n    }\r\n\r\n    rawMsg.valueNames = valueNames\r\n    return [origMsg, rawMsg]\r\n  } else {\r\n    return [origMsg, rawMsg]\r\n  }\r\n}\r\n\r\nmodule.exports = de.biancoroyal.modbus.io.core\r\n"]}