{"version":3,"sources":["core/modbus-queue-core.js"],"names":["require","install","de","biancoroyal","modbus","queue","core","internalDebug","initQueue","node","clear","sendingAllowed","unitSendingAllowed","step","bufferCommandList","set","queuesAreEmpty","get","length","queueSerialUnlockCommand","this","name","serialSendingAllowed","queueSerialLockCommand","sequentialDequeueCommand","Promise","resolve","parallelUnitIdsAllowed","unitId","shift","Error","queueLog","JSON","stringify","queueCore","sendQueueDataToModbus","isValidUnitId","reject","warn","infoText","type","queueLength","command","callModbus","msg","cb","cberr","dequeueLogEntry","state","info","actualServiceState","then","err","message","delay","commandDelay","parseInt","payload","unitid","unit_id","dequeueCommand","messageAllowedStates","indexOf","pushToQueueByUnitId","coreQueue","getUnitIdToQueue","getQueueLengthByUnitId","queueUnitId","clienttype","push"],"mappings":"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","file":"../../core/modbus-queue-core.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus\r\n node-red-contrib-modbusio\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n */\r\n'use strict'\r\nrequire('source-map-support').install()\r\n\r\n// eslint-disable-next-line no-var\r\nvar de = de || { biancoroyal: { modbus: { queue: { core: {} } } } } // eslint-disable-line no-use-before-define\r\nde.biancoroyal.modbus.queue.core.internalDebug = de.biancoroyal.modbus.queue.core.internalDebug || require('debug')('contribModbus:queue:core') // eslint-disable-line no-use-before-define\r\nde.biancoroyal.modbus.queue.core.core = de.biancoroyal.modbus.queue.core.core || require('./modbus-core') // eslint-disable-line no-use-before-define\r\n\r\nde.biancoroyal.modbus.queue.core.initQueue = function (node) {\r\n  node.bufferCommandList.clear()\r\n  node.sendingAllowed.clear()\r\n  node.unitSendingAllowed = []\r\n\r\n  for (let step = 0; step <= 255; step++) {\r\n    node.bufferCommandList.set(step, [])\r\n    node.sendingAllowed.set(step, true)\r\n  }\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.checkQueuesAreEmpty = function (node) {\r\n  let queuesAreEmpty = true\r\n  for (let step = 0; step <= 255; step++) {\r\n    queuesAreEmpty &= (node.bufferCommandList.get(step).length === 0)\r\n  }\r\n  return queuesAreEmpty\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.queueSerialUnlockCommand = function (node) {\r\n  this.internalDebug('queue serial unlock command node ' + node.name)\r\n  node.serialSendingAllowed = true\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.queueSerialLockCommand = function (node) {\r\n  this.internalDebug('queue serial lock command node ' + node.name)\r\n  node.serialSendingAllowed = false\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.sequentialDequeueCommand = function (node) {\r\n  this.internalDebug('sequential de-queue command')\r\n  return new Promise(\r\n    function (resolve, reject) {\r\n      const queueCore = de.biancoroyal.modbus.queue.core\r\n\r\n      if (node.parallelUnitIdsAllowed) {\r\n        for (let unitId = 0; unitId < 256; unitId += 1) {\r\n          queueCore.sendQueueDataToModbus(node, unitId)\r\n        }\r\n      } else {\r\n        const unitId = node.unitSendingAllowed.shift()\r\n        if (!unitId) {\r\n          reject(new Error('UnitId is valid from sending allowed list'))\r\n          return\r\n        }\r\n\r\n        node.queueLog(JSON.stringify({\r\n          type: 'sequential dequeue command',\r\n          unitId,\r\n          isValidUnitId: queueCore.isValidUnitId(unitId),\r\n          sendingAllowed: node.sendingAllowed.get(unitId),\r\n          serialSendingAllowed: node.serialSendingAllowed\r\n        }))\r\n\r\n        if (queueCore.isValidUnitId(unitId) &&\r\n          node.sendingAllowed.get(unitId)) {\r\n          queueCore.sendQueueDataToModbus(node, unitId)\r\n        } else {\r\n          node.warn('sequential dequeue command not possible for Unit ' + unitId)\r\n          let infoText = 'sending is allowed for Unit '\r\n          if (node.sendingAllowed.get(unitId)) {\r\n            node.warn(infoText + unitId)\r\n          } else {\r\n            node.warn('no ' + infoText + unitId)\r\n          }\r\n          infoText = 'valid  Unit '\r\n          if (queueCore.isValidUnitId(unitId)) {\r\n            node.warn(infoText + unitId)\r\n          } else {\r\n            node.warn('no ' + infoText + unitId)\r\n          }\r\n          infoText = ' serial sending allowed for Unit '\r\n          if (node.serialSendingAllowed) {\r\n            node.warn(node.name + infoText + unitId)\r\n          } else {\r\n            node.warn(node.name + ' no' + infoText + unitId)\r\n          }\r\n        }\r\n      }\r\n      resolve()\r\n    })\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.sendQueueDataToModbus = function (node, unitId) {\r\n  const queueLength = node.bufferCommandList.get(unitId).length\r\n  node.queueLog(JSON.stringify({\r\n    type: 'send queue data to Modbus',\r\n    unitId,\r\n    queueLength,\r\n    sendingAllowed: node.sendingAllowed.get(unitId),\r\n    serialSendingAllowed: node.serialSendingAllowed\r\n  }))\r\n\r\n  if (queueLength) {\r\n    const command = node.bufferCommandList.get(unitId).shift()\r\n    if (command) {\r\n      node.sendingAllowed.set(unitId, false)\r\n      command.callModbus(node, command.msg, command.cb, command.cberr)\r\n    } else {\r\n      throw new Error('Command On Send Not Valid')\r\n    }\r\n  }\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.dequeueLogEntry = function (node, state, info) {\r\n  node.queueLog(JSON.stringify({\r\n    state: state.value,\r\n    message: `${info} ${node.clienttype}`,\r\n    delay: node.commandDelay\r\n  }))\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.dequeueCommand = function (node) {\r\n  const queueCore = de.biancoroyal.modbus.queue.core\r\n  const state = node.actualServiceState\r\n\r\n  if (node.messageAllowedStates.indexOf(state.value) === -1) {\r\n    queueCore.dequeueLogEntry(node, state, 'dequeue command disallowed state')\r\n  } else {\r\n    queueCore.sequentialDequeueCommand(node).then(function () {\r\n      queueCore.dequeueLogEntry(node, state, 'dequeue command done')\r\n    }).catch(function (err) {\r\n      queueCore.dequeueLogEntry(node, state, 'dequeue command error ' + err.message)\r\n    })\r\n  }\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.getUnitIdToQueue = function (node, msg) {\r\n  return parseInt(msg.payload.unitid) || parseInt(node.unit_id) || 0\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.isValidUnitId = function (unitId) {\r\n  return (unitId >= 0 || unitId <= 255)\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.getQueueLengthByUnitId = function (node, unitId) {\r\n  if (this.isValidUnitId(unitId)) {\r\n    return node.bufferCommandList.get(unitId).length\r\n  } else {\r\n    throw new Error('(0-255) Got A Wrong Unit-Id: ' + unitId)\r\n  }\r\n}\r\n\r\nde.biancoroyal.modbus.queue.core.pushToQueueByUnitId = function (node, callModbus, msg, cb, cberr) {\r\n  const coreQueue = de.biancoroyal.modbus.queue.core\r\n\r\n  return new Promise(\r\n    function (resolve, reject) {\r\n      try {\r\n        const unitId = coreQueue.getUnitIdToQueue(node, msg)\r\n        if (!unitId) {\r\n          reject(new Error('UnitId is valid from msg or node'))\r\n          return\r\n        }\r\n        const queueLength = coreQueue.getQueueLengthByUnitId(node, unitId)\r\n\r\n        msg.queueLengthByUnitId = { unitId, queueLength }\r\n        msg.queueUnitId = unitId\r\n\r\n        if (!node.parallelUnitIdsAllowed || node.clienttype === 'serial') {\r\n          node.unitSendingAllowed.push(unitId)\r\n        }\r\n\r\n        node.bufferCommandList.get(unitId).push({ callModbus: callModbus, msg: msg, cb: cb, cberr: cberr })\r\n        node.queueLog(JSON.stringify({\r\n          info: 'pushed to Queue by Unit-Id',\r\n          message: msg.payload,\r\n          unitId\r\n        }))\r\n        resolve()\r\n      } catch (err) {\r\n        reject(err)\r\n      }\r\n    })\r\n}\r\n\r\nmodule.exports = de.biancoroyal.modbus.queue.core\r\n"]}