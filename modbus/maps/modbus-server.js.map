{"version":3,"sources":["modbus-server.js"],"names":["module","exports","RED","require","install","net","coreServer","internalDebugLog","message","payload","modbusServer","config","this","name","mbBasics","logEnabled","hostname","parseInt","serverPort","responseDelay","delayUnit","ModbusServer","bufferFactor","coilsBufferSize","holdingBufferSize","inputBufferSize","discreteBufferSize","node","showErrors","setNodeStatusTo","modbusLogLevel","settings","netServer","Server","modbus","server","TCP","logLabel","calc_rateByUnit","logLevel","alloc","coils","Buffer","discrete","on","socket","JSON","stringify","client","address","remoteAddress","remotePort","listen","showStatusActivities","setNodeDefaultStatus","err","buildMessage","msg","send","holding","type","input","isValidMemoryMessage","error","disableMsgOutput","done","close"],"mappings":"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","file":"../modbus-server.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n **/\r\n/**\r\n * Modbus Server node.\r\n * @module NodeRedModbusServer\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const modbus = require('jsmodbus')\r\n  const net = require('net')\r\n  const coreServer = require('./core/modbus-server-core')\r\n  const mbBasics = require('./modbus-basics')\r\n  const internalDebugLog = require('debug')('contribModbus:server')\r\n\r\n  function ModbusServer (config) {\r\n    RED.nodes.createNode(this, config)\r\n    const bufferFactor = 8\r\n\r\n    this.name = config.name\r\n    this.logEnabled = config.logEnabled\r\n    this.hostname = config.hostname || '0.0.0.0'\r\n    this.serverPort = parseInt(config.serverPort)\r\n    this.responseDelay = parseInt(config.responseDelay) || 1\r\n    this.delayUnit = config.delayUnit\r\n\r\n    this.coilsBufferSize = parseInt(config.coilsBufferSize * bufferFactor)\r\n    this.holdingBufferSize = parseInt(config.holdingBufferSize * bufferFactor)\r\n    this.inputBufferSize = parseInt(config.inputBufferSize * bufferFactor)\r\n    this.discreteBufferSize = parseInt(config.discreteBufferSize * bufferFactor)\r\n\r\n    this.showErrors = config.showErrors\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n\r\n    node.netServer = null\r\n    node.modbusServer = null\r\n\r\n    mbBasics.setNodeStatusTo('initialized', node)\r\n\r\n    let modbusLogLevel = 'warn'\r\n    if (RED.settings.verbose) {\r\n      modbusLogLevel = 'debug'\r\n    }\r\n\r\n    try {\r\n      node.netServer = new net.Server()\r\n      node.modbusServer = new modbus.server.TCP(node.netServer, {\r\n        logLabel: 'ModbusServer',\r\n        logLevel: modbusLogLevel,\r\n        logEnabled: node.logEnabled,\r\n        responseDelay: mbBasics.calc_rateByUnit(node.responseDelay, node.delayUnit),\r\n        coils: Buffer.alloc(node.coilsBufferSize, 0),\r\n        holding: Buffer.alloc(node.holdingBufferSize, 0),\r\n        input: Buffer.alloc(node.inputBufferSize, 0),\r\n        discrete: Buffer.alloc(node.discreteBufferSize, 0)\r\n      })\r\n\r\n      node.modbusServer.on('connection', function (client) {\r\n        internalDebugLog('Modbus Server client connection')\r\n        if (client && client.socket) {\r\n          internalDebugLog('Modbus Server client to ' + JSON.stringify(client.socket.address()) + ' from ' + client.socket.remoteAddress + ' ' + client.socket.remotePort)\r\n        }\r\n        mbBasics.setNodeStatusTo('active', node)\r\n      })\r\n\r\n      node.netServer.listen(node.serverPort, node.hostname, () => {\r\n        internalDebugLog('Modbus Server listening on modbus://' + node.hostname + ':' + node.serverPort)\r\n        mbBasics.setNodeStatusTo('initialized', node)\r\n      })\r\n\r\n      if (!node.showStatusActivities) {\r\n        mbBasics.setNodeDefaultStatus(node)\r\n      }\r\n    } catch (err) {\r\n      internalDebugLog(err.message)\r\n      if (node.showErrors) {\r\n        node.warn(err)\r\n      }\r\n      mbBasics.setNodeStatusTo('error', node)\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      if (coreServer.isValidMemoryMessage(msg)) {\r\n        coreServer.writeToServerMemory(node, msg)\r\n        if (!msg.payload.disableMsgOutput) {\r\n          node.send(buildMessage(msg))\r\n        }\r\n      } else {\r\n        if (node.showErrors) {\r\n          node.error('Is Not A Valid Memory Write Message To Server', msg)\r\n        }\r\n        if (!msg.payload.disableMsgOutput) {\r\n          node.send(buildMessage(msg))\r\n        }\r\n      }\r\n    })\r\n\r\n    function buildMessage (msg) {\r\n      return [\r\n        { type: 'holding', message: msg, payload: node.modbusServer.holding },\r\n        { type: 'coils', message: msg, payload: node.modbusServer.coils },\r\n        { type: 'input', message: msg, payload: node.modbusServer.input },\r\n        { type: 'discrete', message: msg, payload: node.modbusServer.discrete },\r\n        { payload: 'request', type: 'message', message: msg }\r\n      ]\r\n    }\r\n\r\n    node.on('close', function (done) {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      if (node.netServer) {\r\n        node.netServer.close(() => {\r\n          internalDebugLog('Modbus Server closed')\r\n          done()\r\n        })\r\n      }\r\n      node.modbusServer = null\r\n    })\r\n  }\r\n\r\n  try {\r\n    RED.nodes.registerType('modbus-server', ModbusServer)\r\n  } catch (err) {\r\n    internalDebugLog(err.message)\r\n  }\r\n}\r\n"]}