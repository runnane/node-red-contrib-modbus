{"version":3,"sources":["modbus-read.js"],"names":["module","exports","RED","require","install","mbCore","mbIOCore","modbusClient","registerForModbus","nodes","createNode","this","config","name","topic","unitid","dataType","adr","ModbusRead","quantity","rate","delayOnStart","parseInt","startDelayTime","rateUnit","showStatusActivities","showErrors","useIOFile","connection","getNode","ioFile","logIOActivities","emptyMsgOnFail","internalDebugLog","node","timeoutOccurred","verboseWarn","logMessage","settings","verbose","warn","serverInfo","INPUT_TIMEOUT_MILLISECONDS","statusText","delayTimerReading","intervalTimerIdReading","setNodeStatusWithTimeTo","id","server","statusValue","statusOptions","newStatusText","mbBasics","setNodeStatusProperties","search","status","get_timeUnit_name","fill","shape","onModbusInit","onModbusConnect","resetAllReadingTimer","onModbusRegister","serialSendingAllowed","initializeReadingTimer","onModbusActive","onModbusQueue","onModbusError","failureMsg","onModbusClose","onModbusBroken","reconnectOnTimeout","reconnectTimeout","onModbusReadDone","resp","msg","response","removeNodeListenerFromModbusClient","origMsg","lastUpdatedAt","deregisterForModbus","sendMessage","values","allValueNames","functionCodeModbusRead","internalDebug","input","sendingNodeId","valueNames","responseBuffer","payload","errorProtocolMsg","err","sendEmptyMsgOnFail","setModbusError","from","messageId","onModbusReadError","resetDelayTimerToRead","clearTimeout","resetIntervalToRead","clearInterval","setInterval","modbusPollingRead","calc_rateByUnit","setTimeout","startIntervalReading","removeListener","done","getTimeInfo","on","httpAdmin","post","auth","needsPermission","req","res","registerType","params","sendStatus","error","_","toString"],"mappings":"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","file":"../modbus-read.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n Copyright 2016 - Jason D. Harper, Argonne National Laboratory\r\n Copyright 2015,2016 - Mika Karaila, Valmet Automation Inc.\r\n Copyright 2013, 2016 IBM Corp. (node-red)\r\n All rights reserved.\r\n node-red-contrib-modbus\r\n\r\n @author <a href=\"mailto:klaus.landsdorf@bianco-royal.de\">Klaus Landsdorf</a> (Bianco Royal)\r\n **/\r\n/**\r\n * Modbus Read node.\r\n * @module NodeRedModbusRead\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const mbCore = require('./core/modbus-core')\r\n  const mbIOCore = require('./core/modbus-io-core')\r\n  const internalDebugLog = require('debug')('contribModbus:read')\r\n\r\n  function ModbusRead (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.topic = config.topic\r\n    this.unitid = config.unitid\r\n\r\n    this.dataType = config.dataType\r\n    this.adr = config.adr\r\n    this.quantity = config.quantity || 1\r\n\r\n    this.rate = config.rate\r\n    this.rateUnit = config.rateUnit\r\n\r\n    this.delayOnStart = config.delayOnStart\r\n    this.startDelayTime = parseInt(config.startDelayTime) || 10\r\n\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n    this.connection = null\r\n\r\n    this.useIOFile = config.useIOFile\r\n    this.ioFile = RED.nodes.getNode(config.ioFile)\r\n    this.useIOForPayload = config.useIOForPayload\r\n    this.logIOActivities = config.logIOActivities\r\n\r\n    this.emptyMsgOnFail = config.emptyMsgOnFail\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n    let timeoutOccurred = false\r\n    node.INPUT_TIMEOUT_MILLISECONDS = 1000\r\n    node.statusText = 'waiting'\r\n    node.delayTimerReading = false\r\n    node.intervalTimerIdReading = false\r\n    setNodeStatusWithTimeTo(node.statusText)\r\n\r\n    function verboseWarn (logMessage) {\r\n      if (RED.settings.verbose) {\r\n        node.warn('Client -> ' + logMessage + node.serverInfo)\r\n      }\r\n    }\r\n\r\n    verboseWarn('open node ' + node.id)\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n\r\n    node.onModbusInit = function () {\r\n      setNodeStatusWithTimeTo('initialized')\r\n    }\r\n\r\n    node.onModbusConnect = function () {\r\n      setNodeStatusWithTimeTo('connected')\r\n      node.resetAllReadingTimer()\r\n      node.initializeReadingTimer()\r\n    }\r\n\r\n    node.onModbusRegister = function () {\r\n      if (node.showStatusActivities) {\r\n        setNodeStatusWithTimeTo('registered')\r\n      }\r\n\r\n      if (modbusClient.serialSendingAllowed) {\r\n        node.resetAllReadingTimer()\r\n        node.initializeReadingTimer()\r\n        setNodeStatusWithTimeTo('connected')\r\n      }\r\n    }\r\n\r\n    node.onModbusActive = function () {\r\n      setNodeStatusWithTimeTo('active')\r\n    }\r\n\r\n    node.onModbusQueue = function () {\r\n      setNodeStatusWithTimeTo('queue')\r\n    }\r\n\r\n    node.onModbusError = function (failureMsg) {\r\n      setNodeStatusWithTimeTo('failure')\r\n      if (modbusClient.reconnectOnTimeout) {\r\n        node.resetAllReadingTimer()\r\n      }\r\n\r\n      if (node.showErrors) {\r\n        node.warn(failureMsg)\r\n      }\r\n    }\r\n\r\n    node.onModbusClose = function () {\r\n      setNodeStatusWithTimeTo('closed')\r\n      node.resetAllReadingTimer()\r\n    }\r\n\r\n    node.onModbusBroken = function () {\r\n      setNodeStatusWithTimeTo('broken')\r\n      if (modbusClient.reconnectOnTimeout) {\r\n        setNodeStatusWithTimeTo('reconnecting after ' + modbusClient.reconnectTimeout + ' msec.')\r\n        node.resetAllReadingTimer()\r\n      }\r\n    }\r\n\r\n    node.onModbusReadDone = function (resp, msg) {\r\n      if (node.showStatusActivities) {\r\n        setNodeStatusWithTimeTo('reading done')\r\n      }\r\n      sendMessage(resp.data, resp, msg)\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.onModbusReadError = function (err, msg) {\r\n      node.internalDebugLog(err.message)\r\n      node.errorProtocolMsg(err, msg)\r\n      mbBasics.setModbusError(node, modbusClient, err, msg)\r\n    }\r\n\r\n    node.modbusPollingRead = function () {\r\n      if (!modbusClient.client) {\r\n        setNodeStatusWithTimeTo('waiting')\r\n        return\r\n      }\r\n\r\n      const msg = {\r\n        topic: node.topic || 'polling',\r\n        from: node.name,\r\n        payload: {\r\n          unitid: node.unitid,\r\n          fc: mbCore.functionCodeModbusRead(node.dataType),\r\n          address: node.adr,\r\n          quantity: node.quantity,\r\n          messageId: mbCore.getObjectId()\r\n        }\r\n      }\r\n\r\n      if (node.showStatusActivities) {\r\n        setNodeStatusWithTimeTo('polling')\r\n      }\r\n\r\n      modbusClient.emit('readModbus', msg, node.onModbusReadDone, node.onModbusReadError)\r\n    }\r\n\r\n    node.resetDelayTimerToRead = function (node) {\r\n      if (node.delayTimerReading) {\r\n        verboseWarn('resetDelayTimerToRead node ' + node.id)\r\n        clearTimeout(node.delayTimerReading)\r\n      }\r\n      node.delayTimerReading = null\r\n    }\r\n\r\n    node.resetIntervalToRead = function (node) {\r\n      if (node.intervalTimerIdReading) {\r\n        verboseWarn('resetIntervalToRead node ' + node.id)\r\n        clearInterval(node.intervalTimerIdReading)\r\n      }\r\n      node.intervalTimerIdReading = null\r\n    }\r\n\r\n    node.resetAllReadingTimer = function () {\r\n      node.resetDelayTimerToRead(node)\r\n      node.resetIntervalToRead(node)\r\n    }\r\n\r\n    node.resetAllReadingTimer()\r\n\r\n    node.startIntervalReading = function () {\r\n      if (!node.intervalTimerIdReading) {\r\n        verboseWarn('startIntervalReading node ' + node.id)\r\n        node.intervalTimerIdReading = setInterval(node.modbusPollingRead, mbBasics.calc_rateByUnit(node.rate, node.rateUnit))\r\n      }\r\n    }\r\n\r\n    node.initializeReadingTimer = function () {\r\n      node.resetAllReadingTimer()\r\n      if (node.delayOnStart) {\r\n        verboseWarn('initializeReadingTimer delay timer node ' + node.id)\r\n        node.delayTimerReading = setTimeout(node.startIntervalReading, node.INPUT_TIMEOUT_MILLISECONDS * node.startDelayTime)\r\n      } else {\r\n        node.startIntervalReading()\r\n      }\r\n    }\r\n\r\n    node.removeNodeListenerFromModbusClient = function () {\r\n      modbusClient.removeListener('mbinit', node.onModbusInit)\r\n      modbusClient.removeListener('mbqueue', node.onModbusQueue)\r\n      modbusClient.removeListener('mbconnected', node.onModbusConnect)\r\n      modbusClient.removeListener('mbactive', node.onModbusActive)\r\n      modbusClient.removeListener('mberror', node.onModbusError)\r\n      modbusClient.removeListener('mbclosed', node.onModbusClose)\r\n      modbusClient.removeListener('mbbroken', node.onModbusBroken)\r\n      modbusClient.removeListener('mbregister', node.onModbusRegister)\r\n      modbusClient.removeListener('mbderegister', node.onModbusClose)\r\n    }\r\n\r\n    this.on('close', function (done) {\r\n      node.resetAllReadingTimer()\r\n      node.removeNodeListenerFromModbusClient()\r\n      setNodeStatusWithTimeTo('closed')\r\n      verboseWarn('close node ' + node.id)\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    function sendMessage (values, response, msg) {\r\n      const topic = msg.topic || node.topic\r\n      if (node.useIOFile && node.ioFile.lastUpdatedAt) {\r\n        if (node.logIOActivities) {\r\n          mbIOCore.internalDebug('node.adr:' + node.adr + ' node.quantity:' + node.quantity)\r\n        }\r\n\r\n        const allValueNames = mbIOCore.nameValuesFromIOFile(node, msg, values, response, node.adr)\r\n        const valueNames = mbIOCore.filterValueNames(node, allValueNames, mbCore.functionCodeModbusRead(node.dataType), node.adr, node.quantity)\r\n\r\n        const origMsg = {\r\n          topic,\r\n          responseBuffer: response,\r\n          input: msg,\r\n          sendingNodeId: node.id\r\n        }\r\n\r\n        if (node.useIOForPayload) {\r\n          origMsg.payload = valueNames\r\n          origMsg.values = values\r\n        } else {\r\n          origMsg.payload = values\r\n          origMsg.valueNames = valueNames\r\n        }\r\n\r\n        node.send([\r\n          origMsg,\r\n          {\r\n            topic,\r\n            payload: response,\r\n            values: values,\r\n            input: msg,\r\n            valueNames: valueNames,\r\n            sendingNodeId: node.id\r\n          }])\r\n      } else {\r\n        node.send([\r\n          {\r\n            topic,\r\n            payload: values,\r\n            responseBuffer: response,\r\n            input: msg,\r\n            sendingNodeId: node.id\r\n          },\r\n          {\r\n            topic,\r\n            payload: response,\r\n            values: values,\r\n            input: msg,\r\n            sendingNodeId: node.id\r\n          }\r\n        ])\r\n      }\r\n    }\r\n\r\n    function setNodeStatusWithTimeTo (statusValue) {\r\n      if (statusValue === 'polling' && timeoutOccurred) {\r\n        return\r\n      }\r\n\r\n      const statusOptions = mbBasics.setNodeStatusProperties(statusValue, node.showStatusActivities)\r\n      const statusText = node.statusText\r\n\r\n      if (statusValue.search('active') !== -1 || statusValue === 'polling') {\r\n        const newStatusText = statusOptions.status + getTimeInfo()\r\n        timeoutOccurred = false\r\n        if (newStatusText !== statusText) {\r\n          node.status({\r\n            fill: statusOptions.fill,\r\n            shape: statusOptions.shape,\r\n            text: newStatusText\r\n          })\r\n        }\r\n      } else {\r\n        const newStatusText = statusOptions.status\r\n        if (newStatusText !== statusText) {\r\n          node.status({\r\n            fill: statusOptions.fill,\r\n            shape: statusOptions.shape,\r\n            text: newStatusText\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    function getTimeInfo () {\r\n      return ' ( ' + node.rate + ' ' + mbBasics.get_timeUnit_name(node.rateUnit) + ' ) '\r\n    }\r\n\r\n    if (node.showStatusActivities) {\r\n      modbusClient.on('mbinit', node.onModbusInit)\r\n      modbusClient.on('mbqueue', node.onModbusQueue)\r\n    }\r\n\r\n    modbusClient.on('mbconnected', node.onModbusConnect)\r\n    modbusClient.on('mbactive', node.onModbusActive)\r\n    modbusClient.on('mberror', node.onModbusError)\r\n    modbusClient.on('mbclosed', node.onModbusClose)\r\n    modbusClient.on('mbbroken', node.onModbusBroken)\r\n    modbusClient.on('mbregister', node.onModbusRegister)\r\n    modbusClient.on('mbderegister', node.onModbusClose)\r\n\r\n    modbusClient.registerForModbus(node)\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-read', ModbusRead)\r\n\r\n  RED.httpAdmin.post('/modbus/read/inject/:id', RED.auth.needsPermission('modbus.inject.write'), function (req, res) {\r\n    const node = RED.nodes.getNode(req.params.id)\r\n\r\n    if (node) {\r\n      try {\r\n        node.modbusPollingRead()\r\n        res.sendStatus(200)\r\n      } catch (err) {\r\n        res.sendStatus(500)\r\n        node.error(RED._('modbusinject.failed', { error: err.toString() }))\r\n      }\r\n    } else {\r\n      res.sendStatus(404)\r\n    }\r\n  })\r\n}\r\n"]}