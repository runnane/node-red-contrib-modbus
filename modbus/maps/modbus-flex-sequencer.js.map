{"version":3,"sources":["modbus-flex-sequencer.js"],"names":["module","exports","RED","install","mbBasics","require","mbCore","internalDebugLog","nodes","registerType","config","createNode","this","mbIOCore","sequences","showStatusActivities","showErrors","ModbusFlexSequencer","connection","logIOActivities","ioFile","getNode","useIOForPayload","emptyMsgOnFail","node","verboseLogging","settings","setNodeStatusTo","server","modbusClient","registerForModbus","initModbusClientEvents","msg","data","resp","emit","err","logMsgError","sendEmptyMsgOnFail","message","origMsg","getOriginalMessage","bufferMessageList","onModbusReadError","JSON","parse","fc","unitid","parseInt","address","quantity","isValidModbusMsg","Number","isInteger","isValid","error","buildNewMessageObject","topic","id","messageId","getObjectId","payload","name","keepMsgProperties","on","client","origMsgInput","Object","assign","forEach","invalidSequencesIn","newMsg","set","onModbusReadDone","buildNewMessage","inputMsg","errorProtocolMsg","actualServiceState","deregisterForModbus","clear","done","setNodeDefaultStatus"],"mappings":"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","file":"../modbus-flex-sequencer.js","sourcesContent":["/**\r\n Copyright (c) 2016,2017,2018,2019,2020,2021 Klaus Landsdorf (https://bianco-royal.space/)\r\n All rights reserved.\r\n node-red-contrib-modbus - The BSD 3-Clause License\r\n\r\n @author <a>Andrea Verardi</a> (Anversoft)\r\n */\r\n\r\n/**\r\n * Modbus Sequencer node.\r\n * @module NodeRedModbusFlexSequencer\r\n *\r\n * @param RED\r\n */\r\nmodule.exports = function (RED) {\r\n  'use strict'\r\n  require('source-map-support').install()\r\n  const mbBasics = require('./modbus-basics')\r\n  const mbCore = require('./core/modbus-core')\r\n  const mbIOCore = require('./core/modbus-io-core')\r\n  const internalDebugLog = require('debug')('contribModbus:poller')\r\n\r\n  function ModbusFlexSequencer (config) {\r\n    RED.nodes.createNode(this, config)\r\n\r\n    this.name = config.name\r\n    this.sequences = config.sequences\r\n\r\n    this.showStatusActivities = config.showStatusActivities\r\n    this.showErrors = config.showErrors\r\n    this.connection = null\r\n\r\n    this.useIOFile = config.useIOFile\r\n    this.ioFile = RED.nodes.getNode(config.ioFile)\r\n    this.useIOForPayload = config.useIOForPayload\r\n    this.logIOActivities = config.logIOActivities\r\n\r\n    this.emptyMsgOnFail = config.emptyMsgOnFail\r\n    this.keepMsgProperties = config.keepMsgProperties\r\n    this.internalDebugLog = internalDebugLog\r\n    this.verboseLogging = RED.settings.verbose\r\n\r\n    const node = this\r\n    node.bufferMessageList = new Map()\r\n    mbBasics.setNodeStatusTo('waiting', node)\r\n\r\n    const modbusClient = RED.nodes.getNode(config.server)\r\n    if (!modbusClient) {\r\n      return\r\n    }\r\n    modbusClient.registerForModbus(node)\r\n    mbBasics.initModbusClientEvents(node, modbusClient)\r\n\r\n    node.onModbusReadDone = function (resp, msg) {\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo('reading done', node)\r\n      }\r\n\r\n      node.send(mbIOCore.buildMessageWithIO(node, resp.data, resp, msg))\r\n      node.emit('modbusFlexSequencerNodeDone')\r\n    }\r\n\r\n    node.errorProtocolMsg = function (err, msg) {\r\n      mbBasics.logMsgError(node, err, msg)\r\n      mbBasics.sendEmptyMsgOnFail(node, err, msg)\r\n    }\r\n\r\n    node.onModbusReadError = function (err, msg) {\r\n      node.internalDebugLog(err.message)\r\n      const origMsg = mbCore.getOriginalMessage(node.bufferMessageList, msg)\r\n      node.errorProtocolMsg(err, origMsg)\r\n      mbBasics.setModbusError(node, modbusClient, err, origMsg)\r\n      node.emit('modbusFlexSequencerNodeError')\r\n    }\r\n\r\n    node.prepareMsg = function (msg) {\r\n      if (typeof msg === 'string') {\r\n        msg = JSON.parse(msg)\r\n      }\r\n\r\n      switch (msg.fc) {\r\n        case 'FC1':\r\n          msg.fc = 1\r\n          break\r\n        case 'FC2':\r\n          msg.fc = 2\r\n          break\r\n        case 'FC3':\r\n          msg.fc = 3\r\n          break\r\n        case 'FC4':\r\n          msg.fc = 4\r\n          break\r\n      }\r\n\r\n      msg.unitid = parseInt(msg.unitid)\r\n      msg.address = parseInt(msg.address) || 0\r\n      msg.quantity = parseInt(msg.quantity) || 1\r\n\r\n      return msg\r\n    }\r\n\r\n    node.isValidModbusMsg = function (msg) {\r\n      let isValid = true\r\n\r\n      if (!(Number.isInteger(msg.unitid) &&\r\n          msg.unitid >= 0 &&\r\n          msg.unitid <= 255)) {\r\n        node.error('Unit ID Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      if (isValid &&\r\n        !(Number.isInteger(msg.address) &&\r\n          msg.address >= 0 &&\r\n          msg.address <= 65535)) {\r\n        node.error('Address Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      if (isValid &&\r\n        !(Number.isInteger(msg.quantity) &&\r\n          msg.quantity >= 1 &&\r\n          msg.quantity <= 65535)) {\r\n        node.error('Quantity Not Valid', msg)\r\n        isValid &= false\r\n      }\r\n\r\n      return isValid\r\n    }\r\n\r\n    node.buildNewMessageObject = function (node, msg) {\r\n      const messageId = mbCore.getObjectId()\r\n      return {\r\n        topic: msg.topic || node.id,\r\n        messageId,\r\n        payload: {\r\n          name: msg.name,\r\n          unitid: msg.unitid,\r\n          fc: msg.fc,\r\n          address: msg.address,\r\n          quantity: msg.quantity,\r\n          emptyMsgOnFail: node.emptyMsgOnFail,\r\n          keepMsgProperties: node.keepMsgProperties,\r\n          messageId\r\n        }\r\n      }\r\n    }\r\n\r\n    node.on('input', function (msg) {\r\n      if (!modbusClient.client) {\r\n        return\r\n      }\r\n\r\n      const origMsgInput = Object.assign({}, msg)\r\n      const sequences = mbBasics.invalidSequencesIn(msg) ? node.sequences : msg.sequences\r\n\r\n      try {\r\n        sequences.forEach(msg => {\r\n          const inputMsg = node.prepareMsg(msg)\r\n          if (node.isValidModbusMsg(inputMsg)) {\r\n            const newMsg = node.buildNewMessageObject(node, inputMsg)\r\n            node.bufferMessageList.set(newMsg.messageId, mbBasics.buildNewMessage(node.keepMsgProperties, inputMsg, newMsg))\r\n            modbusClient.emit('readModbus', newMsg, node.onModbusReadDone, node.onModbusReadError)\r\n          }\r\n        })\r\n      } catch (err) {\r\n        node.errorProtocolMsg(err, origMsgInput)\r\n      }\r\n\r\n      if (node.showStatusActivities) {\r\n        mbBasics.setNodeStatusTo(modbusClient.actualServiceState, node)\r\n      }\r\n    })\r\n\r\n    node.on('close', function (done) {\r\n      mbBasics.setNodeStatusTo('closed', node)\r\n      node.bufferMessageList.clear()\r\n      modbusClient.deregisterForModbus(node.id, done)\r\n    })\r\n\r\n    if (!node.showStatusActivities) {\r\n      mbBasics.setNodeDefaultStatus(node)\r\n    }\r\n  }\r\n\r\n  RED.nodes.registerType('modbus-flex-sequencer', ModbusFlexSequencer)\r\n}\r\n"]}